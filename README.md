## Початок навчання та створення програми на React
###### 27.07.2022
Цей проект було створено за допомогою [Create React App](https://github.com/facebook/create-react-app).\
У каталозі проекту ви можете запустити:  
* `npm i` (або `npm install` ) Використовується для встановлення всіх залежностей або devDependencies із файлу package.json.
* `npm start`  Запускає програму в режимі розробки.

Відкрийте [http://localhost:3000](http://localhost:3000) щоб переглянути його у своєму браузері.\
Сторінка перезавантажиться, коли ви внесете зміни.

------
### Конспект:
#### -- Урок 01.
React-розробка в першу чергу має на увазі розробку для браузера, тобто `front-end розробка`. 
А `NodeJS` потрібний для, як відомо, серверної розробки.

---	
#### -- Урок 02. (Навіщо NodeJS на фронті)*
* Браузер(Хром,Опера)-програма в якій працює JS.
* NodeJS - програма, яка знаходиться на сервері (замість браузера) і в ньому працює JS./
* Браузер і NodeJS використовують один і той же двигун v8-тому обох сприймає JS.
* Npm,Yarn -пакетний менеджер(встановлює та стежить за купою пакетів у NodeJS).
* React-працює з NodeJS-т.к. тут є всі необхідні пакети для компіляції та виведення даних.

---	
#### -- Урок 03. (Установка NodeJS)
* `sudo apt-get install nodejs`
* `sudo apt-get install npm`
---		
#### -- Урок 04. (create-react-app)\
`NPX` - це інструмент, який потрібен для спрощення використання утиліт та виконуваних файлів. Також він допомагає використовувати утиліти без run-скрипту та запускати команди з різними версіями ноди.
* `npx create-react-app my-app`  - змінити my-app на назву проєкту
* `cd my-app`
* `npm start`
---	
#### -- Урок 05. (SPA)
* SPA (Single Page Application) — веб додаток, який взаємодіє з користувачем шляхом динамічного переписування поточної сторінки. Тобто, SPA - це web-додаток, розміщений на одній web-сторінці, яка завантажує весь необхідний код разом із завантаженням самої сторінки.

Основні переваги SPA:
   1.  Збільшення чуйності інтерфейсу web-додатку. Оскільки весь необхідний код завантажується відразу, то при подальшій взаємодії з ним вміст сторінки змінюється миттєво.
   2.  Зменшення навантаження на сервер програми. Взаємодія з сервером відбувається лише під час завантаження сторінки. Це означає, що зменшується кількість запитів до сервера й навантаження нього.
   3.  Поліпшення UX. Той факт, що вам не потрібно чекати перезавантаження сторінки при кожній взаємодії з нею що приносить більше задоволення від її використання.
   4.  Зменшення обсягу даних, які передаються. Усі дані завантажуються спочатку, отже той же масив даних не передаватиметься по кілька разів.
---
#### -- Урок 06. (index.js, App, JSX)\
`JavaScript XML (JSX)` - це розширення синтаксису JavaScript, яке дозволяє використовувати HTML-подібний синтаксис для опису структури інтерфейсу
   1. Є `index.html` - це єдиний файл, який прийде користувачеві в браузер;
   2. Все, що покаже index.html і вся подальша логіка знаходиться тепер у `app.js`;
   3. В `App.js` знаходиться перший наш компонент, написаний на `JSX`;
   4. Якщо потрібно, щоб компонент повернув групу тегів, їх необхідно обернути на один батьківський тег;

---
#### -- Урок 07. (Компонанта)
Компонента - це Самодостатосний елемент(функція) який повертає JSX код та робить ще багато Чого)\
Наприклад :
`function Welcome () {
	return <h1>Hello, am React Component</h1>;
}` і також можливо використовувати Стрілкову Функцію
`const Welcome = () => {
	return <h1>Hello, am React Component</h1>
}` на компоненти можливо розділити частини HTML та використовувати їх неодноразово. 
Щоб викликати компоненту необхідно вставити її як тег `<Welcome />`\
**Як правило всі назви компонентів мають починатися з Великої Літери. (використовуємо стиль [CamelCase](https://ru.wikipedia.org/wiki/CamelCase))**

---
#### -- Урок 08. (import\export - теорія)\
Компоненти можливо рознести в окремі файли роздробити Основну сторінку. 
Цей компонент в окремому файлі повинен `Експортувати` вказавши `export default`та **Назву**  
дозволити використовувати свою функцію за межами свого файлу,
щоб з іншого файлу зробити його `Імпорт` та викликати Компоненту при потребі
через `import Назва from './файл.jsx';` символ `./` зазначає що **_файл.jsx_** знаходиться в тій же теці де прописуємо імпорт
або  `./../` - вийде з поточного місця на рівень вище 

---
#### -- Урок 09. (import export наших компонент)
Наприклад у нас є наша створена компонента **Welcome** винесемо в окремий файл `Welcome.jsx` 
та пропишемо у файлі  `export default Welcome;` щоб функція стала доступна за межами файлу \
У файлі **App.js** визвем через тег `<Welcome />` нашу компоненту і обов'язково робимо  **Імпорт**
прописуємо `import Welcome from './Welcome.jsx';`
цього файлу.\
Створимо ще один Компонент який поверне `<h2>Hello, World!</h2>` назвемо її `Hello` та винесемо в окремий файл `Hello.jsx` та одразу  **Експортуєм**  \
Отримаєм такий код \
`const Hello = () => {
return ( <h2>Hello, World!</h2> )
}`\
`export default Hello;`

---
#### Урок 10. (default помилковість імпорту)
Спробуємо імпортувати функцію **Welcome** з файлу `Hello.jsx`
 _(помилково вкажемо не вірний файл)_ `import  Welcome from './Hello.jsx';`
та викликати її тегом `<Welcome />` 
у нас вернуся код `<h2>Hello, World!</h2>`  \
Сам файл **Hello.jsx** не має функції **Welcome**, але через `export default` передає в нашу **Welcome** функцію **Hello**

---
#### Урок 11. (шаг 1, соціальна мережа, вёрстка, grid)
###### Ми 10 уроків ми готувалися, і на 11-му ми починаємо бомбити з вами нашу _соціальну мережу!!!_
**Grid** – це модуль для створення табличних, двовимірних макетів, що дозволяють розміщувати елементи у рядках та стовпцях макета.\
Верстка--

    <div className="app-wraper">` головний Батьківський Тег
        <header className='header'></header>
        <nav className='sidebar'></nav>
        <div className='content'></div>
    </div> 
CSS - (стилі) записуються в файлі **App.css**\
`.grid { 
display:grid;` Перетворює елемент на grid контейнер.\
`grid-template-areas:
"header header"
"nav content";` Описує сітку \
╔═════════════════╗\
║____header__________header_____║\
╠═════╦═══════════╣\
║_________║____________________║\
║___nav___║_________content_____║\
║_________║____________________║\
╚═════╩═══════════╝\
`grid-template-rows: 60px 1fr;` Вибудовує ряди у гриді. Кожне значення становить розмір ряду. \
`grid-template-columns: 2fr 10fr;` Те саме, що й вище, лише визначає колонки у грідах.\
`grid-gap: 10px; }`Виставляє розрив. Тобто прогалини між грід елементами.\
Властивість grid-area - це скорочення, яке дозволяє вам розміщувати грід-елементи в гриді.\
`.header { grid-area: header;} 
.sidebar { grid-area: nav; }
.content { grid-area: content;}`

---
#### Урок 12. (Розбивка на компоненты)
######  Ну, нічого складного... Ми зліпили все до купи. А ось зараз ми роздробимо наш "**моноліт**" на компоненти. Адже в *компонентах* та *дробленні* суть **React-а** ;)
Наш готовий код з   `<header class='header'></header>` перенесемо в файл **Header.jsx**. 
Пам'ятаємо про Експорт!
`const Header = () => {
return ( <header class='header'></header> )
}`
`export default Header;`\
повторимо для інших компонентів `nav` та `content`\
в результаті отримали три різні компоненти
 * Header.jsx 
 * NavBar.jsx 
 * Content.jsx\

Додамо теги компонентів в App.js та одразу імпортуємо їх:

    import './App.css';
    import React from 'react';
    import Header from './Header.jsx';
    import NavBar from './NavBar.jsx';
    import Content from './Content.jsx';

    const App = () => {
        return (
            <div className="App_grid">
                <Header />
                <NavBar />   
                <Content />
            </div>
        );
    }
    export default App;

---
#### Урок 13. (git-репозиторий)
###### Команди [GIT](https://training.github.com/downloads/ru/github-git-cheat-sheet/) вигрузка на репозиторій

---
#### Урок 14. (css-модулі)
###### Створюючи такі свої особисті компоненти\блоки\теги, ми дробимо наш додаток і нам зручно. Хотілося б якось ще й css писати так, щоб сильно не заганятися і все само працювало)) У React є кілька походів по роботі зі стилями. _Використовуватимемо css модулі_!!!

У нас Створені компоненти про те їх стилі CSS зберігаються в одному файлі.
React надає можливість зробити інкапсуляцію відокремити кожен елемент стилю, 
наприклад компонент **Header** може містити тег **item** та **img** 
та ціж теги ще будуть використовуватися в **Content** \
Для компонентів створимо персональні стилі `Header.module.css`присутність **.module.** в назві обов'язкова \
Імпортуємо файл стилів в саму компоненту `import s from './Headers.module.css';`
у такий спосіб стилі передаються вибраному псевдоніму `S` (За домовленістю всі стилі на проєкті будуть призначені цьому псевдоніму )\
`<div className="content">` в компоненті така назва класу уже є некоректною 
нумо використовувати псевдонім `S` \
Будова стилів виглядає так: 

	let s = {
		'content' : 'Header_content__4gt9Q',
		'item' : 'Header_item__4trD3',
		'img' : 'Header_img__4jkC6'
Стилі що передаються з файлу `Header.module.css` уже універсальні. 
Прикладом `<div className="item">` уже стає `className="Header_item__4trD3"` \
_Призначення було спростити та пришвидшити роботу, а не Розтягувати її !!_ - **і саме так**)) \
	Візьмем наш приклад `<div className="item">` і допрацюємо його змінивши назву на
`<div className={s.item}>` хоча це **_JSX-(HTML)_** використали `{ }` оголосили що тут Буде **_JavaScript_** 

`{s.content}` складається з : \
* `s`       - наш Токін(Псевдонім) якому призначенні CSS стилі. 
* `content` - ключ який прописаний в імпортованому **Style.module.css** з якого повернеться повна Індивідуальна назва класу

``className={`${s.alert} ${props.warm}`}>`` - спосіб передачі двох і більше Класів







